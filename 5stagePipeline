#include <iostream>
#include <vector>
#include <thread>

using namespace std;

// Define a simple instruction set
enum class Opcode {
    ADD,
    SUB,
    MUL,
    LOAD,
    STORE
};

struct Instruction {
    Opcode opcode;
    int operand1;
    int operand2;
    int result;
};

class RISCPipeline {
public:
    void fetch(int);
    void decode();
    void execute();
    void memory();
    void writeBack();
    void run();

private:
    vector<Instruction> instructions;
    int pc; // Program Counter
    bool halt;
    int registers[32]; // General-purpose registers
    string memory1[10] = {'ADD','SUB','MUL', 'LOAD','STORE'};   // Simple ins memory
};

void RISCPipeline::fetch(int programCounter) {
    // Fetch instruction from memory using the program counter
    if(programCounter%32!=0){
    cout<<"misaligned memory address-need to refetch"<<endl;
    }
    else{
     RISCPipeline::pc = programCounter;
    cout<<"Inside Fetch- PC="<<RISCPipeline::pc<<endl;
    }
   
}

void RISCPipeline::decode() {
    // Decode the fetched instruction
    cout<<RISCPipeline::pc;
    cout<<"Inside Decode"<<endl;
}

void RISCPipeline::execute() {
    // Execute the decoded instruction
    cout<<"Inside Execute"<<endl;
}

void RISCPipeline::memory() {
    // Perform memory operations (e.g., load or store)
    cout<<"Inside Memory"<<endl;
}

void RISCPipeline::writeBack() {
    // Write the result back to registers
    cout<<"Write Back"<<endl;
    halt = true;
}

/*void RISCPipeline::run() {
    
    
    std::thread t1(RISCPipeline.fetch);
    std::thread t2(RISCPipeline.decode);
    std::thread t3(RISCPipeline.execute);
    std::thread t4(RISCPipeline.memory);
    std::thread t5(RISCPipeline.writeBack);

    // Join threads to wait for their completion
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    t5.join();
    
}*/

int main() {
    RISCPipeline pipeline;
    thread t1(&RISCPipeline::fetch, &pipeline, 192);
    thread t2(&RISCPipeline::decode, &pipeline);
    thread t3(&RISCPipeline::execute, &pipeline);
    thread t4(&RISCPipeline::memory, &pipeline);
    thread t5(&RISCPipeline::writeBack, &pipeline);
	
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    t5.join();


    return 0;
}
